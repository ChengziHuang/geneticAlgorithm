# A genetic algorihtm to solve the Travelling Salesman Problem

## Usage

```shell
make
./TSP a280.tsp
```

All parameters are configure in the parameter.h file.

## idea

The initial solutions used by genetic algorithm  are found by 2-opt.

The crossover operator uses the edges to cross:

&emsp; **Step 1:** A pair of parents is denoted as P<sub>A</sub> and P<sub>B</sub>, and G<sub>AB</sub> is defined as a graph constructed by merging P<sub>A</sub> and P<sub>B</sub>.

&emsp; **Step 2:** Divide edges on G<sub>AB</sub> into AB-cycles, where an AB-cycle is defined as a closed loop on G<sub>AB</sub> that can be generated by alternately tracing edges of P<sub>A</sub> and P<sub>B</sub>.

&emsp; **Step 3:** Construct an E-set by selecting AB-cycles.

&emsp; **Step 4:** Generate an intermediate solution by applying E-set to P<sub>A</sub>, i.e., by removing P<sub>A</sub>’s edges in the E-set from P<sub>A</sub> and adding P<sub>B</sub>’s edges in the E-set to it.

&emsp; **Step 5:** Modify the intermediate solution to create a valid tour by connecting its sub-tours. Two sub-tours are connected by respectively deleting one edge from each sub-tour and adding two edges to connect them.

![Illustration of the Crossover operator](https://github.com/ChengziHuang/geneticAlgorithm/blob/master/figure/combinate.png)

## main framework

1. {x<sub>1</sub>,..., x<sub>pop</sub>} := 2-opt()
2. **repeat**
3. &emsp; r(.) := a random permutation of 1,..., x<sub>pop</sub>
4. &emsp; **for** i := 1 to   x<sub>pop</sub>  **do**
5. &emsp; &emsp; p<sub>A</sub> := x<sub>r(i)</sub>, p<sub>B</sub> := x<sub>r(i+1)</sub>
6. &emsp; &emsp; {c<sub>1</sub>,...,c<sub>N<sub>ch</sub></sub>} := Crossover(p<sub>A</sub>, p<sub>B</sub>)
7. &emsp; &emsp; x<sub>r(i)</sub> := Select(c<sub>1</sub>,...,c<sub>N<sub>ch</sub></sub>, p<sub>A</sub>)
8. &emsp; **end for**
9. **until** a termination condition is satisfied
10. **return** the best individual in the population